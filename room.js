import { isValidPosition } from "./public/positionValidator.js"

const colors = [0, 1, 2, 3]

export class Room {
    constructor() {
        this.players = new Map()
        this.sockets = []
        this.boardChanges = []
        this.board = new Array(20)
            .fill(0)
            .map(() => new Array(20).fill(0).map(() => -1))
        this.availablePieces = new Array(4)
            .fill(0)
            .map(() => new Array(21).fill(0).map(() => true))
    }

    /**
     * Place a polymino on the board and notify all the players
     * @param {*} msg The message generated by the player that should be sent to clients
     * @param {number} polymino The polymino to place
     * @param {boolean} firstMove Whether this is the player's first move
     */
    placePolymino(msg, polymino, firstMove) {
        if (!this.isValidPosition(msg.x, msg.y, polymino, msg.color, firstMove))
            return

        this.firstMove = false

        this.availablePieces[msg.color][msg.index] = false

        this.boardChanges.push(msg)

        let size = Math.sqrt(polymino.length)

        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                if (polymino[j * size + i] === 1) {
                    this.board[msg.x + i][msg.y + j] = msg.color
                }
            }
        }

        Array.from(this.players.values()).forEach(otherPlayer => {
            if (otherPlayer.color !== null) otherPlayer.sendPlacedPolymino(msg)
        })
    }

    /**
     * Check if a move is valid
     * @param {number} x X position
     * @param {number} y Y position
     * @param {number[]} polymino Which polymino to use
     * @param {number} playerColor The polymino's color
     * @param {boolean} firstMove If this is the player's first move
     * @returns {boolean}
     */
    isValidPosition(x, y, polymino, playerColor, firstMove) {
        return isValidPosition(
            this.board,
            x,
            y,
            polymino,
            playerColor,
            firstMove
        )
    }

    /**
     * Get which colors aren't already taken by players
     * @returns {number[]}
     */
    availableColors() {
        return colors.filter(
            c =>
                !Array.from(this.players.values()).reduce(
                    (a, v) => a || v.color === c,
                    false
                )
        )
    }
}
